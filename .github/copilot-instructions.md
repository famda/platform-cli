# Semantics CLI - Comprehensive Implementation Prompt

## Project Overview

You are building a **modular, extensible CLI tool** called `semantics` that processes different file types (audio, video, documents, etc.) using specialized handlers. The CLI is designed to be **distributed as standalone executables** via GitHub Releases, with different variants for different use cases.

## Key Requirements

### Architecture
- **Single unified CLI** with file-type-based routing and **chained flag operations**: `semantics <file-type> <input> --operation1 --operation2 -o <output>`
- **Plugin-based module system** with dynamic discovery and loading
- **Multiple executable variants** - users download the variant matching their needs
- **Graceful module loading** - if a module isn't available in the executable variant, show a simple error
- **Modern Python tooling** - use `uv` as the package manager, `pyproject.toml` for configuration
- **Input is always a file**, output is always a folder

### Technology Stack
- **CLI Framework**: Click (chained flag operations, not nested subcommands)
- **Package Manager**: uv (for development)
- **Python Version**: >= 3.12
- **Configuration**: `pyproject.toml` (hatchling backend with hatch-vcs dynamic versioning)
- **Build System**: hatchling + hatch-vcs
- **Distribution**: PyInstaller (for creating standalone executables)

## Project Structure

```
platform-cli/
‚îú‚îÄ‚îÄ pyproject.toml                    # All configuration here
‚îú‚îÄ‚îÄ uv.lock                           # Generated by uv (add to git)
‚îú‚îÄ‚îÄ README.md                         # Project documentation
‚îú‚îÄ‚îÄ build.py                          # PyInstaller build script
‚îú‚îÄ‚îÄ tests/                            # Test files at root level
‚îÇ   ‚îú‚îÄ‚îÄ test_cli.py
‚îÇ   ‚îî‚îÄ‚îÄ test_version.py
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îú‚îÄ‚îÄ ci.yml                    # CI pipeline with tests
‚îÇ       ‚îî‚îÄ‚îÄ release.yml               # Release workflow for artifacts
‚îî‚îÄ‚îÄ src/
    ‚îî‚îÄ‚îÄ semantics/
        ‚îú‚îÄ‚îÄ __init__.py
        ‚îú‚îÄ‚îÄ __main__.py               # Entry point for python -m semantics
        ‚îú‚îÄ‚îÄ cli.py                    # Main CLI entry point with ModuleRegistry + extension routing
        ‚îî‚îÄ‚îÄ modules/
            ‚îú‚îÄ‚îÄ __init__.py
            ‚îú‚îÄ‚îÄ audio/
            ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
            ‚îÇ   ‚îú‚îÄ‚îÄ cli.py            # Audio command with chained flags
            ‚îÇ   ‚îú‚îÄ‚îÄ handlers/         # handlers folder for audio operations
            ‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ transcribe.py     # Transcription handler with handle() function
            ‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ ...py             # Other audio handlers
            ‚îú‚îÄ‚îÄ video/
            ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
            ‚îÇ   ‚îú‚îÄ‚îÄ cli.py            # Video command with chained flags
            ‚îÇ   ‚îú‚îÄ‚îÄ handlers/         # handlers folder for video operations
            ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transcribe.py     # Video transcription handler
            ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...py             # Other video handlers
            ‚îî‚îÄ‚îÄ document/
                ‚îú‚îÄ‚îÄ __init__.py
                ‚îú‚îÄ‚îÄ cli.py            # Document command with chained flags
                ‚îú‚îÄ‚îÄ handlers/         # handlers folder for document operations
                ‚îÇ   ‚îú‚îÄ‚îÄ extract_text.py    # Text extraction handler
                ‚îÇ   ‚îî‚îÄ‚îÄ ...py             # Other document handlers
```

**Note on Dependencies**: Handler implementations will import heavy dependencies locally within function bodies, NOT at the module level. This allows lazy loading and graceful degradation when dependencies are missing.

## pyproject.toml Configuration

Create a `pyproject.toml` with the following characteristics:

### Build System (hatchling + hatch-vcs)
```toml
[build-system]
requires = ["hatchling", "hatch-vcs"]
build-backend = "hatchling.build"
```

### Project Metadata
- Package name: `semantics`
- Dynamic versioning: Use `hatch-vcs` to derive version from git tags
- Mark `version` as dynamic in `[project]` section: `dynamic = ["version"]`
- Description: "Process different file types with specialized AI handlers"
- Python requirement: `>=3.12`
- Author and license fields (use placeholder values)

### Core Dependencies
- `click>=8.1.0` (CLI framework only, no heavy dependencies)

### Optional Dependencies (per-module)

Define `[project.optional-dependencies]` structure as:

```toml
[project.optional-dependencies]
audio = [
    # Audio processing dependencies will go here
    # Example: librosa, soundfile, numpy, whisper
]

video = [
    # Video processing dependencies will go here
    # Example: opencv-python, numpy
]

document = [
    # Document processing dependencies will go here
    # Example: pdf2image, pytesseract, pillow
]

all = [
    "semantics[audio,video,document]",
]

dev = [
    "pytest>=8.0.0",
    "pytest-cov>=4.0.0",
    "black>=23.0.0",
    "ruff>=0.1.0",
    "pyinstaller>=6.0.0",
]
```

### Entry Point
- Script name: `semantics`
- Entry point: `semantics.cli:main`

### hatch-vcs Configuration
Add version source configuration for git-based versioning with src layout:

```toml
[tool.hatch.version]
source = "vcs"

[tool.hatch.build.hooks.vcs]
version-file = "src/semantics/_version.py"
```

### Tool Configuration Sections
- `[tool.hatch.build.targets.wheel]` - Configure packages for src layout: `packages = ["src/semantics"]`
- `[tool.pytest.ini_options]` - test configuration
- `[tool.black]` - code formatter settings
- `[tool.ruff]` - linter settings

## Core CLI Implementation (src/semantics/cli.py)

### ModuleRegistry Class
Create a `ModuleRegistry` class that:

1. **Dynamically loads modules** from the `src/semantics/modules/` directory
   - Discovers all modules with a `cli.py` file
   - Loads them lazily using `importlib.util`
   - Gracefully handles missing modules (silently skip)

2. **Tracks failures**
   - Stores failed module names
   - Provides error messages when user tries to access unavailable modules
   - **Important**: Do NOT expose internal import errors or traceback details

3. **Methods**:
   - `register(name, module_path)` - Load a single module from file
   - `load_all_modules()` - Discover and load all modules from `src/semantics/modules/` directory
   - `get_unavailable_modules()` - Return list of modules that couldn't be loaded

### Main CLI Group
- Function: `main()` decorated with `@click.group()`
- Description: "Semantics CLI - Process different file types"
- Version option enabled (auto-populated from hatch-vcs)
- Help text with basic examples

### Module Registration
- Create `ModuleRegistry` instance at module load time
- Call `registry.load_all_modules()` to auto-discover all modules
- Add each loaded command to the main CLI with `main.add_command()`

### Error Handling for Missing Modules

**For bundled executables (PyInstaller):**

The CLI will be distributed as multiple standalone executables (see Distribution section below). Each executable is built with specific modules baked in.

When a module can't be loaded:

1. **In modular executables** (semantics-audio, semantics-video, semantics-document):
   - Show: `Error: Audio module is not available in this version.`
   - This indicates user downloaded the wrong executable variant

2. **In full executable** (semantics):
   - Show: `Error: Unable to load audio module. Please report it.`
   - This indicates a bug or corrupted bundle

**For source development (pip installation):**

When running from source and a module fails to load during development:
- Show: `Error: This feature requires additional dependencies. Run: uv pip install -e ".[audio]"`
- This only applies during source development, not in final distributed executables

### Help System
- `semantics --help` - Show only available commands for this executable variant
- `semantics audio --help` - Show audio-specific options and flags
- Unavailable modules should be silently omitted, not listed as "not available"
- No mention of installation or dependency management in help text

## Module Structure

### Chained Flag Pattern

Each module uses a **single Click command with multiple flags** rather than nested subcommands. The CLI imports separate handler scripts and delegates to their `handle()` functions:

```python
# src/semantics/modules/audio/cli.py
import click
from pathlib import Path

from semantics.modules.audio.handlers import extract_metadata, transcribe

@click.command()
@click.argument("input", type=click.Path(exists=True, dir_okay=False))
@click.option("--output", "-o", type=click.Path(file_okay=False), required=True,
              help="Output folder for results")
@click.option("--transcribe", "do_transcribe", is_flag=True, help="Transcribe audio to text")
@click.option("--extract-metadata", "do_extract_metadata", is_flag=True, help="Extract audio metadata")
@click.option("--language", "-l", default="en", help="Language for transcription")
@click.option("--model", "-m", default="base",
              type=click.Choice(["tiny", "base", "small", "medium", "large"]),
              help="Model size for transcription")
@click.option("--verbose", "-v", is_flag=True, help="Enable verbose output")
def cli(input: str, output: str, do_transcribe: bool, do_extract_metadata: bool,
        language: str, model: str, verbose: bool) -> None:
    """Process audio files with various operations."""
    if not do_transcribe and not do_extract_metadata:
        raise click.ClickException(
            "At least one operation required: --transcribe, --extract-metadata"
        )
    
    input_path = Path(input)
    output_path = Path(output)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Execute requested operations via handler modules
    if do_transcribe:
        transcribe.handle(input_path, output_path, verbose=verbose, 
                         language=language, model=model)
    
    if do_extract_metadata:
        extract_metadata.handle(input_path, output_path, verbose=verbose)
```

### Each Module Must Export
- A Click command named `cli` in `src/semantics/modules/<type>/cli.py`
- The command accepts an `input` argument and `--output` option
- Multiple `is_flag=True` options for different operations
- A `--verbose` flag passed to all handlers
- Validation that at least one operation is specified

### Handler Script Pattern

Each operation flag has a corresponding handler script with a `handle()` function:

```python
# src/semantics/modules/audio/handlers/transcribe.py
from pathlib import Path
import click

def handle(input_path: Path, output_path: Path, verbose: bool = False, **options) -> None:
    """
    Handle audio transcription.
    
    Args:
        input_path: Path to the input audio file.
        output_path: Path to the output folder.
        verbose: Enable verbose output.
        **options: Additional options (language, model).
    """
    language = options.get("language", "en")
    model = options.get("model", "base")

    if verbose:
        click.echo(f"üîß Options: language={language}, model={model}")

    click.echo(f"üéµ Transcribing audio: {input_path.name}")
    click.echo(f"   Output folder: {output_path}")

    # TODO: Implement actual transcription with heavy dependencies
    # try:
    #     import whisper
    #     model_obj = whisper.load_model(model)
    #     result = model_obj.transcribe(str(input_path))
    # except ImportError:
    #     raise click.ClickException(
    #         'This feature requires additional dependencies. '
    #         'Run: uv pip install -e ".[audio]"'
    #     )

    click.echo("‚úÖ Transcription complete (dummy)")
```

### Handler Requirements
- Each handler is in a separate `.py` file named after the operation (e.g., `transcribe.py`)
- Must export a `handle()` function with signature: `handle(input_path: Path, output_path: Path, verbose: bool = False, **options) -> None`
- Heavy dependencies are imported inside the function (lazy loading)
- Use `click.echo()` for output messages
- Raise `click.ClickException` for user-facing errors

### Example: Audio Module (src/semantics/modules/audio/cli.py)

**Flags**:
1. `--transcribe` - Convert audio to text
   - Option: `--language` (language code, default: 'en')
   - Option: `--model` (model size selection, default: 'base')

2. `--extract-metadata` - Get audio metadata

**Common Options**:
- Argument: `input` (file path, must exist)
- Option: `--output` (output folder, required)
- Option: `--verbose` (enable verbose output)

**Handler Files**:
- `transcribe.py` - Contains `handle()` function for transcription
- `extract_metadata.py` - Contains `handle()` function for metadata extraction

### Example: Video Module (src/semantics/modules/video/cli.py)

**Flags**:
1. `--transcribe` - Transcribe video audio to text

2. `--detect-objects` - Detect objects in video using YOLO
   - Option: `--confidence` (threshold 0.0-1.0, default: 0.5)
   - Option: `--model` (model size selection, default: 'base')

**Common Options**:
- Argument: `input` (file path, must exist)
- Option: `--output` (output folder, required)
- Option: `--verbose` (enable verbose output)

**Handler Files**:
- `transcribe.py` - Contains `handle()` function for transcription
- `detect_objects.py` - Contains `handle()` function for object detection

### Example: Document Module (src/semantics/modules/document/cli.py)

**Flags**:
1. `--extract-text` - Extract text from document (PDF, image, etc.)
   - Option: `--format` (output format: text/json, default: text)

**Common Options**:
- Argument: `input` (file path, must exist)
- Option: `--output` (output folder, required)
- Option: `--verbose` (enable verbose output)

**Handler Files**:
- `extract_text.py` - Contains `handle()` function for text extraction

## Extension-Based Routing

The CLI supports automatic module detection based on file extension:

```python
# src/semantics/cli.py
EXTENSION_MAP: dict[str, str] = {
    # Audio formats
    ".wav": "audio", ".mp3": "audio", ".flac": "audio", ".ogg": "audio",
    ".m4a": "audio", ".aac": "audio", ".wma": "audio",
    # Video formats
    ".mp4": "video", ".avi": "video", ".mkv": "video", ".mov": "video",
    ".wmv": "video", ".webm": "video", ".flv": "video",
    # Document formats
    ".pdf": "document", ".png": "document", ".jpg": "document",
    ".jpeg": "document", ".tiff": "document", ".bmp": "document", ".gif": "document",
}
```

This enables both explicit and auto-routed usage:

```bash
# Explicit module (always works)
semantics audio input.wav -o ./output --transcribe

# Auto-routed via -i/--input option (detects module from extension)
semantics -i input.mp4 -o ./output --transcribe
semantics -i document.pdf -o ./output --extract-text
```

The `-i/--input` option triggers auto-routing based on file extension and validates that the requested flags are valid for the detected module.

## Usage Examples (Source Development)

The final CLI should support:

```bash
# Help system
semantics --help
semantics audio --help

# Core functionality - chained flag pattern
semantics audio input.wav --transcribe -o ./output
semantics audio input.wav --transcribe --extract-metadata -o ./output
semantics audio input.wav --transcribe --language es -o ./output
semantics video video.mp4 --detect-objects --confidence 0.7 -o ./output
semantics document document.pdf --extract-text --format json -o ./output

# Extension-based routing (auto-detects module via -i/--input)
semantics -i input.mp4 -o ./output --transcribe
semantics -i input.wav -o ./output --transcribe --extract-metadata
semantics -i document.pdf -o ./output --extract-text

# Verbose output
semantics audio input.wav -o ./output --transcribe -v
semantics -i input.mp4 -o ./output --transcribe --verbose

# With missing dependencies (source development only)
$ semantics audio input.wav --transcribe -o ./output
Error: This feature requires additional dependencies.
Run: uv pip install -e ".[audio]"
```

## Installation Instructions (Development)

For developers working on source code:

```bash
# Development setup (core + dev tools)
uv sync

# Development setup with specific modules
uv sync --extra audio
uv sync --extra audio,video

# Development setup with all modules
uv sync --extra all
```

## Distribution: Bundled Executables via GitHub Releases

This project is distributed as **pre-built standalone executables** via GitHub Releases. Users download the variant matching their needs.

### Executable Variants

Four executables are built and released for each version:

1. **semantics-audio-{version}.exe**
   - Audio processing only
   - Includes: audio module + all audio dependencies
   - Users needing only audio transcription/metadata

2. **semantics-video-{version}.exe**
   - Video processing only
   - Includes: video module + all video dependencies
   - Users needing only video object detection

3. **semantics-document-{version}.exe**
   - Document processing only
   - Includes: document module + all document dependencies
   - Users needing only text extraction

4. **semantics-{version}.exe**
   - Full version with all modules
   - Includes: all modules + all dependencies
   - Users wanting all features

### Build Process

A Python build script (`build.py`) is provided in the repository:

```bash
# Build all variants
python build.py all

# Build specific variant
python build.py audio
python build.py video
python build.py document
python build.py full
```

The build script:
- Uses PyInstaller to create standalone executables
- Specifies which modules to include for each variant
- Configures hidden imports for PyInstaller discovery
- Outputs executables to `dist/` directory

### PyInstaller Configuration

Each variant is built with:
- `--onefile` - Single executable file
- `--hidden-import` - Explicit imports for PyInstaller
- Module-specific dependencies baked in
- No external dependencies required by end users

### GitHub Releases

Releases are created with per-platform, per-variant executables using the following naming convention:

```
GitHub Releases (v0.1.0)
‚îú‚îÄ‚îÄ semantics-v0.1.0-linux-x86_64.zip
‚îú‚îÄ‚îÄ semantics-v0.1.0-windows-x86_64.zip
‚îú‚îÄ‚îÄ semantics-v0.1.0-macos-x86_64.zip
‚îú‚îÄ‚îÄ semantics-audio-v0.1.0-linux-x86_64.zip
‚îú‚îÄ‚îÄ semantics-audio-v0.1.0-windows-x86_64.zip
‚îú‚îÄ‚îÄ semantics-audio-v0.1.0-macos-x86_64.zip
‚îú‚îÄ‚îÄ semantics-video-v0.1.0-linux-x86_64.zip
‚îú‚îÄ‚îÄ semantics-video-v0.1.0-windows-x86_64.zip
‚îú‚îÄ‚îÄ semantics-video-v0.1.0-macos-x86_64.zip
‚îú‚îÄ‚îÄ semantics-document-v0.1.0-linux-x86_64.zip
‚îú‚îÄ‚îÄ semantics-document-v0.1.0-windows-x86_64.zip
‚îî‚îÄ‚îÄ semantics-document-v0.1.0-macos-x86_64.zip
```

Users download the appropriate zip for their platform and use case.

### Error Messages in Bundled Executables

Since dependencies are pre-built into each executable:

**User tries wrong variant:**
```
$ semantics-audio video video.mp4 --detect-objects -o ./output
Error: Video module is not available in this version.
```

**Full executable has corrupted module (bug):**
```
$ semantics audio audio.wav --transcribe -o ./output
Error: Unable to load audio module.
```

**Source installation (development only):**
```
$ semantics audio audio.wav --transcribe -o ./output
Error: This feature requires additional dependencies.
Run: uv pip install -e ".[audio]"
```

## Requirements

### Code Quality
- ‚úÖ Type hints throughout (at least for function signatures)
- ‚úÖ Docstrings for all classes and public functions
- ‚úÖ Clean, user-friendly error messages (no internal details)
- ‚úÖ Proper Click command/group structure with comprehensive help text
- ‚úÖ No hardcoded paths - use relative paths from package root
- ‚úÖ Python 3.12+ syntax allowed (f-strings, walrus operator, type unions with `|`)

### Robustness
- ‚úÖ Graceful handling of missing modules
- ‚úÖ Validation of input file paths (check they exist using Click's Path type)
- ‚úÖ Clear, user-facing error messages (no Python tracebacks)
- ‚úÖ No internal module failures exposed in help or status messages
- ‚úÖ Missing modules silently skipped (not advertised in help)

### Maintainability
- ‚úÖ DRY principle - no duplicate code between modules
- ‚úÖ Easy to add new modules (just create new folder in `modules/`)
- ‚úÖ Module discovery is automatic (no manual registration needed)
- ‚úÖ Extensible handler pattern (heavy imports inside functions)
- ‚úÖ Consistent error handling across all modules

### Testing (Optional but Recommended)
- ‚úÖ Unit tests for handlers (with mocked file I/O)
- ‚úÖ Integration tests for CLI commands
- ‚úÖ Tests for missing module scenarios
- ‚úÖ pytest configuration in pyproject.toml

## Special Considerations

### Module Independence
- Modules should not import from each other
- Shared logic (if any) should go in a separate `semantics/core/` package
- Each module's dependencies are completely independent

### Dynamic Loading Robustness
- Use `importlib.util.spec_from_file_location()` for dynamic imports
- Handle cases where module file exists but has syntax errors
- Store module objects properly in `sys.modules` to avoid reimports
- Catch ImportError when loading module `cli.py` and silently skip

### Heavy Dependency Handling
- **CRITICAL**: Import heavy dependencies INSIDE handler functions, NOT at module level
- This enables graceful degradation without loading unused dependencies
- Example: `import librosa` inside the `handle()` function, not at top of `transcribe.py`
- Wrap these imports in try-except with user-friendly error messages

### User-Friendly Error Messages
- Never show raw Python tracebacks for expected errors
- For bundled executables: simple error indicating module not available in this variant
- For source development: suggest installation command
- Use emoji/colors for visual clarity (‚úÖ ‚ùå)
- Keep messages concise and actionable

### Package Metadata
- Use hatch-vcs for automatic versioning from git tags
- Include helpful README.md with examples
- Clear instructions on downloading the right executable variant
- Architecture explanation for developers

## Non-Requirements (Don't Do)

- ‚ùå Don't include actual heavy dependencies in optional-dependencies yet
- ‚ùå Don't ask users to create requirements.txt per module
- ‚ùå Don't use environment variables to control module loading
- ‚ùå Don't use subprocess delegation
- ‚ùå Don't copy dependencies between modules
- ‚ùå Don't use lazy module discovery with configuration files
- ‚ùå Don't ignore ImportError - always handle gracefully
- ‚ùå Don't mix Click decorators and imperative code
- ‚ùå Don't import heavy dependencies at module level (import only in handlers)
- ‚ùå Don't advertise missing modules in `--help` output
- ‚ùå Don't show package manager commands (pip/uv) in bundled executable error messages

### Deliverables

### Source Code
1. **pyproject.toml** - Complete, with hatchling + hatch-vcs, all sections configured
2. **src/semantics/__init__.py** - Package init with version export
3. **src/semantics/__main__.py** - Entry point for python -m semantics
4. **src/semantics/cli.py** - Main entry point with ModuleRegistry + extension routing
5. **src/semantics/modules/__init__.py** - Modules package init
6. **src/semantics/modules/audio/__init__.py** - Package init
7. **src/semantics/modules/audio/cli.py** - Audio module with chained flags
8. **src/semantics/modules/audio/handlers/transcribe.py** - Transcription handler with `handle()` function
9. **src/semantics/modules/audio/handlers/extract_metadata.py** - Metadata extraction handler
10. **src/semantics/modules/video/__init__.py** - Package init
11. **src/semantics/modules/video/cli.py** - Video module with chained flags
12. **src/semantics/modules/video/handlers/transcribe.py** - Video transcription handler
13. **src/semantics/modules/video/handlers/detect_objects.py** - Object detection handler
14. **src/semantics/modules/document/__init__.py** - Package init
15. **src/semantics/modules/document/cli.py** - Document module with chained flags
16. **src/semantics/modules/document/handlers/extract_text.py** - Text extraction handler
17. **README.md** - Project documentation, installation, usage examples, architecture
18. **tests/** - Test files at root level (test_cli.py, test_version.py)

### Build Configuration
19. **build.py** - Python build script for creating PyInstaller executables (optional but recommended)
    - Configures PyInstaller for each variant
    - Handles hidden imports per module
    - Outputs to `dist/` directory

## Implementation Notes

- Start with pyproject.toml (it defines the entire project structure)
- Configure hatchling + hatch-vcs for automatic versioning
- Then implement src/semantics/cli.py with ModuleRegistry
- Then implement each module's cli.py with chained flag pattern
- Handlers should wrap heavy dependency imports in try-except (but don't import yet)
- Make sure ModuleRegistry auto-discovers all modules and silently skips failures
- Error messages for source development should suggest `uv pip install -e ".[module]"`
- Version should be automatically derived from git tags (hatch-vcs)

## Implementation Workflow

**IMPORTANT**: Every project change must include tests. Follow this workflow:

1. **Understand the change** - Read existing code and understand the impact
2. **Write tests first** - Create or update tests in `tests/` folder
3. **Implement the change** - Make the code changes
4. **Run tests** - Execute `uv run pytest -v` to verify all tests pass
5. **Verify CLI** - Run `uv run semantics --help` to ensure CLI works

### Test Requirements
- Unit tests for all handler functions
- Integration tests for CLI commands using Click's CliRunner
- Tests for error cases (missing input, invalid options, etc.)
- Tests for chained flag operations
- Tests should be placed in `tests/` folder at root level

### Running Tests
```bash
# Install dev dependencies
uv sync --extra dev

# Run all tests
uv run pytest -v

# Run with coverage
uv run pytest --cov=semantics --cov-report=term-missing

# Run specific test file
uv run pytest tests/test_cli.py -v
```

## Success Criteria

‚úÖ Single unified CLI with file-type routing  
‚úÖ Modular architecture with auto-discovery  
‚úÖ Optional per-module dependencies structure defined  
‚úÖ Graceful handling of missing modules (silent skip, clear errors when accessed)  
‚úÖ Heavy dependencies imported only in handlers (lazy loading)  
‚úÖ Missing modules silently skipped from help  
‚úÖ Clean, readable code with proper typing (Python 3.12+)  
‚úÖ Comprehensive help system  
‚úÖ Easy to extend with new modules  
‚úÖ Automatic versioning with hatch-vcs  
‚úÖ Production-ready error handling  
‚úÖ Source code runs with `uv sync` and `uv pip install -e ".[module]"`  
‚úÖ Ready for PyInstaller bundling (no external dependencies in executable)  
‚úÖ Multiple executable variants documented  
