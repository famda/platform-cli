name: Release

# This workflow is triggered on pushes to main branch
# It uses Conventional Commits to determine the next version automatically
# and creates a GitHub Release with per-OS downloadable ZIP artifacts
on:
  push:
    branches: [main]

# Permissions for release workflow
# - contents: write - needed to create releases and push tags
# - issues: write - needed by python-semantic-release
# - pull-requests: write - needed by python-semantic-release
permissions:
  contents: write
  issues: write
  pull-requests: write

# Prevent concurrent releases
concurrency:
  group: release
  cancel-in-progress: false

jobs:
  # First job: Determine version and create release
  release:
    name: Create Release
    runs-on: ubuntu-latest
    
    # Only run if the commit is not from the release bot itself
    if: "!contains(github.event.head_commit.message, 'chore(release)')"
    
    outputs:
      released: ${{ steps.release.outputs.released }}
      version: ${{ steps.release.outputs.version }}
      tag: ${{ steps.release.outputs.tag }}
    
    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      
      # Use Python Semantic Release to handle versioning based on Conventional Commits
      # This tool:
      # - Analyzes commits since the last tag
      # - Determines the next version using semantic versioning:
      #   * feat: -> MINOR version bump
      #   * fix:/perf: -> PATCH version bump
      #   * feat!/BREAKING CHANGE: -> MAJOR version bump
      # - Updates version in pyproject.toml
      # - Creates a git tag
      # - Generates release notes from commit messages
      - name: Python Semantic Release
        id: release
        uses: python-semantic-release/python-semantic-release@v9.12.0
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          root_options: "-vv"

  # Second job: Attach pre-built artifacts to release
  # The artifacts are built by the CI workflow
  attach-artifacts:
    name: Attach ${{ matrix.platform }} artifact to release
    runs-on: ubuntu-latest
    needs: release
    
    # Only run if a release was created
    if: needs.release.outputs.released == 'true'
    
    strategy:
      matrix:
        platform: [linux, windows, macos]
    
    steps:
      # Download pre-built artifacts from the CI workflow
      # These artifacts were created by the build-artifacts job in ci.yml
      # We use dawidd6/action-download-artifact to download from another workflow
      - name: Download artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          commit: ${{ github.sha }}
          name: semantics-${{ matrix.platform }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
      
      # Upload the artifact to the GitHub Release
      - name: Upload artifact to release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.release.outputs.tag }}
          files: semantics-${{ matrix.platform }}.zip
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
